阅读两篇论文的总结：一、<<AndroBench: Benchmarking the Storage Performance of Android-Based Mobile Devices>>文章介绍了一个测量安卓平台内存性能的基准工具，测量的性能包括：顺序I/O存取、随机I/O存取和SQLite数据库的吞吐量性能，分析了在进行这三方面性能测量时值得注意的问题，并进行了其他类似的测量工具的比较。AndroBench是一个可以在网上下载的android性能测试工具，将其安装在手机上，可以通过执行AndroBench，测量收集顺序I/O存取、随机I/O存取和SQLite数据库的吞吐量性能，AndroBench会将对本机的测量数据显示出来，并生成历史日志；同时server端将这些测量数据返回到server端（返回数据包括机型和测量结果），server端通过这样的方式收集到大量测量数据后对数据进行分析。AndroBench包括setting选项，方便用户选择三者中任意某一方面进行性能测量。文章中提出对于内存性能测量主要受到底层存储介质性能的制约。手机内存使用了一种内嵌式存储器（如下图所示：eMMC (Embedded Multi Media Card) 为MMC协会所订立的、主要是针对手机或平板电脑等产品的内嵌式存储器标准规格。）
eMMC中集成了NAND闪存、MMC接口、controller。构成内存的底层存储介质。除此之外，文件系统、I/O表的优化对内存性能的测量有较大影响。文中提到，在对内存性能进行测量时，一个重要的问题是要最小化buffer cache的影响。由于android没有提供可以绕过buffer cache的库，因此，AndroBench采取的方案是使用C实现Java Native Interface（JNI）接口。android不提供superuser的权限（我认为是root权限不能默认提供）也给内存测量带来一些需要解决的问题。在android平台，SQLite被用于存储contacts、SMSes和bookmarks等信息的系统和用户级数据库。它在host文件系统中作为一个单独的文件存储所有的数据库信息。对SQLite的性能测量类似于对内存性的性能测量。文章非常简要介绍了对测量结果分析的方法，举例介绍了server端收集的数据分析结果，如下图所示：
Average performance数值越大说明相应性能越高。结果表明：内存顺序读中，GT-I9100机型性能最好；内存顺序写中,GT-P1000机型性能最好；内存随机读中，SHW-M110S机型性能最好；内存随机写中，HTC Desire机型性能最好。SQLite Insert、Update、delete性能：都是HTC Desire机型性能最好。以下是AndroBench下载运行结果：  
文章最后说明了eMMC的升级不一定会全部内存性能的读写性能，可以看到，在提高内存顺序读的性能时，内存顺序写的性能降低；不同的文件系统对内存读写性能的影响也是不同的。
我的疑问：1.android版本不同对内存机制的影响；不同型号的内存性能不同，这对内存回收的影响2.android内存结构
二、<<A Survey on Android vs. Linux>>文章比较了linux和android设计框架、内核、使用的库之间的区别，介绍了android的运行时环境Dalvik Virtual Machine、文件系统和能量管理机制。文中介绍android使用了x86的部分设计，生产mobile的厂商均使用ARM设计。ARM使用了精简指令集，适用于android的小内存、低功耗、小代码量。而linux使用了x86设计，x86设计使用了复杂指令集。文中介绍android是基于linux实现的，但不完全使用linux的标准内核。android设计了独有的时钟驱动、共享内存驱动、内部线程通信接口、能量管理、low memory killer、内核调试器和记录器。android的运行时环境Dalvik Virtual Machine（DVM）优化了内存空间，包括：    减少VM的内存占用空间；DVM没有及时编译器；常量池被优化为只有32位id，简化了解释器；使用自己的字节码，而不是java字节码；文中介绍了android的文件系统的底层机制。android使用flash memory代替硬盘。flash memory包括NOR flash 和NAND flash。NOR具有低速写、高速读的特点，适用于code执行，NAND具有低成本、高速写、低速读的特点，适用于数据存储。然而，NAND具有块擦除低效、内存读写磨损的限制，android通过Bad block management（BBM）改善了这一限制问题。android使用的文件系统是YAFFS，由JFFS发展而来。由于JFFS主要使用NOR增加NAND的支持，boot time较长，RAM消耗较大，因此不适用android应用。并且，使用NOR和NAND之间有很多的不同之处，因此android根据NAND flash的特点和约束，为确保鲁棒性形成一套专用于NAND flash 的文件系统，且该文件系统也可用于NOR flash，只是效果不是很好。YAFFS降低了对内存的要求，其模块化设计适用于多种操作系统。相比JFFS，YAFFS的garbage collection更加的简洁、快速。文章还介绍了android能量管理机制，与内存机制的关系不大，在此不做总结。
